#!/opt/opensvc/bin/python
""" 
module use OSVC_COMP_GROUP_... vars
which define {'groupname':{'propname':'propval',... }, ...}

example: 
{"tibco":{"gid":1000,"members":"tibco,tibadm",},
 "tibco1":{"gid":1001,"members":"tibco",},
}

supported dictionnary keys:
- members

dictionnary keys used by another module:
- gid
"""

import os
import sys
import json
import grp
from subprocess import Popen 

RET_OK = 0
RET_ERR = 1
RET_NA = 2

RET = RET_ERR

PREFIX = 'OSVC_COMP_GROUP_'

grt = {
    'members': 'gr_mem',
}

groupmod_p = {}

sysname, nodename, x, x, machine = os.uname()

if sysname not in ['SunOS', 'Linux']:
    print 'module not supported on', sysname
    sys.exit(RET_NA)

#
# initialize a hash to store all group membership
# of users
#
member_of = {}
for group in grp.getgrall():
    for user in group.gr_mem:
        if user in member_of:
            member_of[user].append(group.gr_name)
        else:
            member_of[user] = [group.gr_name]

groups = {}
for k in [ key for key in os.environ if key.startswith(PREFIX)]:
    try:
        groups.update(json.loads(os.environ[k]))
    except ValueError:
        print 'group syntax error on var[', k, '] = ',os.environ[k]

if len(groups) == 0:
    print "no applicable variable found in rulesets",PREFIX
    sys.exit(RET_NA)

def fixable():
    return RET_NA

def del_member(group, user):
    if user not in member_of:
        return 0
    g = set(member_of[user]) - set([group])
    g = ','.join(g)
    return fix_member(g, user)

def add_member(group, user):
    if user in member_of:
        g = set(member_of[user]) | set([group])
        g = ','.join(g)
    else:
        g = group
    return fix_member(g, user)

def fix_member(g, user):
    cmd = ['usermod', '-G', g, user]
    print ' '.join(cmd)
    p = Popen(cmd)
    out, err = p.communicate()
    r = p.returncode    
    if r == 0:
        return RET_OK
    else:
        return RET_ERR

def fix_members(group, target):
    r = 0
    for user in target:
        if user in member_of and group in member_of[user]:
            continue
        r += add_member(group, user)
    for user in [u for u in member_of if group in member_of[u] and u not in target]:
        r += del_member(group, user)
    return r

def fix_item(group, item, target):
    if item == 'members':
        return fix_members(group, target)
    else:
        print >>sys.stderr, 'no fix implemented for', item
        return RET_ERR

def check_item(group, item, target, current, verbose=False):
    if (isinstance(current, list) and set(target) == set(current)) or target == current:
        if verbose:
            print 'OK: group:', group, item+':', current
        return RET_OK
    else:
        if verbose:
            print >>sys.stderr, 'group:', group, item+':', current, 'target:', target
        return RET_ERR 

def check_group(group, props):
    r = 0
    try:
        groupinfo = grp.getgrnam(group)
    except KeyError:
        print 'group', group, 'does not exist'
        return RET_OK
    for prop in grt:
        if prop in props:
            r |= check_item(group, prop, props[prop], getattr(groupinfo, grt[prop]), verbose=True)
    return r

def fix_group(group, props):
    r = 0
    try:
        groupinfo = grp.getgrnam(group)
    except KeyError:
        print 'group', group, 'does not exist'
        return RET_OK
    for prop in grt:
        if prop in props and \
           check_item(group, prop, props[prop], getattr(groupinfo, grt[prop])) != RET_OK:
            r |= fix_item(group, prop, props[prop])
    return r

def check():
    r = 0
    for group, props in groups.items():
        r |= check_group(group, props)
    return r

def fix():
    r = 0
    for group, props in groups.items():
        r |= fix_group(group, props)
    return r

#
# Main
#
if len(sys.argv) != 2:
    print >>sys.stderr, "need argument"
    sys.exit(RET_ERR)
try:
    if sys.argv[1] == 'check':
        RET = check()
    elif sys.argv[1] == 'fix':
        RET = fix()
    elif sys.argv[1] == 'fixable':
        RET = fixable()
    else:
        print >>sys.stderr, "unsupported argument '%s'"%sys.argv[1]
        RET = RET_ERR
except:
    import traceback
    traceback.print_exc()
    sys.exit(RET_ERR)

sys.exit(RET)
