#!/opt/opensvc/bin/python
""" 
Verify file content. The collector provides the format with
wildcards. The module replace the wildcards with contextual
values.

The variable format is json-serialized:

{
  "path": "/some/path/to/file",
  "fmt": "root@corp.com		%%HOSTNAME%%@corp.com"
}

Wildcards:
%%ENV:VARNAME%%		Any environment variable value
%%HOSTNAME%%		Hostname
%%SHORT_HOSTNAME%%	Short hostname

"""

import os
import sys
import json
import stat
import re
import urllib
import tempfile
import pwd
import grp
from subprocess import *

RET_OK = 0
RET_ERR = 1
RET_NA = 2

RET = RET_OK

PREFIX = 'OSVC_COMP_FILES_'

_usr = {}
_grp = {}

sysname, nodename, x, x, machine = os.uname()

def parse_fmt(d):
    fmt = d['fmt']
    p = re.compile('%%ENV:.+%%')
    for m in p.findall(fmt):
        s = m.strip("%").replace('ENV:', '')
        if s in os.environ:
            v = os.environ[s]
        elif 'OSVC_COMP_'+s in os.environ:
            v = os.environ['OSVC_COMP_'+s]
        else:
            print >>sys.stderr, s, 'is not an env variable'
            RET = RET_ERR
            return []
        fmt = fmt.replace(m, v)
    fmt = fmt.replace('%%HOSTNAME%%', nodename)
    fmt = fmt.replace('%%SHORT_HOSTNAME%%', nodename.split('.')[0])
    d['fmt'] = fmt
    return [d]

def parse_ref(d):
    f = tempfile.NamedTemporaryFile()
    tmpf = f.name
    fname, headers = urllib.urlretrieve(d['ref'], tmpf)
    if 'invalid file' in headers.values():
        print >>sys.stderr, d['ref'], "not found on collector"
        return RET_ERR
    d['fmt'] = f.read()
    f.close()
    return parse_fmt(d)

def add_file(v):
    d = json.loads(v)
    if 'path' not in d:
        print >>sys.stderr, 'path should be in the dict:', os.environ[k]
        RET = RET_ERR
        return []
    if 'fmt' not in d and 'ref' not in d:
        print >>sys.stderr, 'fmt or ref should be in the dict:', os.environ[k]
        RET = RET_ERR
        return []
    if 'fmt' in d and 'ref' in d:
        print >>sys.stderr, 'fmt and ref are exclusive:', os.environ[k]
        RET = RET_ERR
        return []
    if 'fmt' in d:
        return parse_fmt(d)
    if 'ref' in d:
        return parse_ref(d)

files = []

for k in [ key for key in os.environ if key.startswith(PREFIX)]:
    try:
        files += add_file(os.environ[k])
    except ValueError:
        print >>sys.stderr, 'failed to parse variable', os.environ[k]

if len(files) == 0:
    print "no applicable variable found in rulesets", PREFIX
    sys.exit(RET_NA)

   
def fixable():
    return RET_NA

def check_file_fmt(f, verbose=False):
    if verbose:
        cmd = ['diff', '-u', f['path'], '-']
    else:
        cmd = ['diff', '-q', f['path'], '-']
    p = Popen(cmd, stdin=PIPE)
    out, err = p.communicate(input=f['fmt'])
    return p.returncode

def check_file_mode(f, verbose=False):
    if 'mode' not in f:
        return RET_OK
    try:
        mode = oct(stat.S_IMODE(os.stat(f['path']).st_mode))
    except:
        if verbose: print >>sys.stderr, f['path'], 'can not stat file'
        return RET_ERR
    mode = str(mode).lstrip("0")
    if mode != f['mode']:
        if verbose: print >>sys.stderr, f['path'], 'mode should be %s but is %s'%(f['mode'], mode)
        return RET_ERR
    return RET_OK

def get_uid(uid):
    if uid in _usr:
        return _usr[uid]
    tuid = uid
    if isinstance(uid, (str, unicode)):
        try:
            info=pwd.getpwnam(uid)
            tuid = info[2]
            _usr[uid] = tuid
        except:
            pass
    return tuid

def get_gid(gid):
    if gid in _grp:
        return _grp[gid]
    tgid = gid
    if isinstance(gid, (str, unicode)):
        try:
            info=grp.getgrnam(gid)
            tgid = info[2]
            _grp[gid] = tgid
        except:
            pass
    return tgid

def check_file_uid(f, verbose=False):
    if 'uid' not in f:
        return RET_OK
    tuid = get_uid(f['uid'])
    uid = os.stat(f['path']).st_uid
    if uid != tuid:
        if verbose: print >>sys.stderr, f['path'], 'uid should be %s but is %s'%(tuid, str(uid))
        return RET_ERR
    return RET_OK

def check_file_gid(f, verbose=False):
    if 'gid' not in f:
        return RET_OK
    tgid = get_gid(f['gid'])
    gid = os.stat(f['path']).st_gid
    if gid != tgid:
        if verbose: print >>sys.stderr, f['path'], 'gid should be %s but is %s'%(tgid, str(gid))
        return RET_ERR
    return RET_OK

def check_file(f, verbose=False):
    if not os.path.exists(f['path']):
        print >>sys.stderr, f['path'], "does not exist"
        return RET_ERR
    r = 0
    r |= check_file_fmt(f, verbose)
    r |= check_file_mode(f, verbose)
    r |= check_file_uid(f, verbose)
    r |= check_file_gid(f, verbose)
    return r

def fix_file_mode(f):
    if 'mode' not in f:
        return RET_OK
    if check_file_mode(f) == RET_OK:
        return RET_OK
    try:
        print "set %s mode to %s"%(f['path'], f['mode'])
        os.chmod(f['path'], int(f['mode'], 8))
    except:
        return RET_ERR
    return RET_OK

def fix_file_owner(f):
    uid = -1
    gid = -1

    if 'uid' not in f and 'gid' not in f:
        return RET_OK
    if 'uid' in f and check_file_uid(f) != RET_OK:
        uid = get_uid(f['uid'])
    if 'gid' in f and check_file_gid(f) != RET_OK:
        gid = get_uid(f['gid'])
    if uid == -1 and gid == -1:
        return RET_OK
    try:
        print "set %s ownership to %d:%d"%(f['path'], uid, gid)
        os.chown(f['path'], uid, gid)
    except:
        return RET_ERR
    return RET_OK

def fix_file_fmt(f):
    if check_file_fmt(f) == RET_OK:
        return RET_OK
    d = os.path.dirname(f['path'])
    if not os.path.exists(d):
       os.makedirs(d)
       os.chown(d, f['uid'], f['gid'])
    try:
        with open(f['path'], 'w') as fi:
            fi.write(f['fmt'])
    except:
        return RET_ERR
    return RET_OK

def check():
    r = 0
    for f in files:
        r |= check_file(f, verbose=True)
    return r

def fix():
    r = 0
    for f in files:
        r |= fix_file_fmt(f)
        r |= fix_file_mode(f)
        r |= fix_file_owner(f)
    return r

#
# Main
#
if len(sys.argv) != 2:
    print >>sys.stderr, "need argument"
    sys.exit(RET_ERR)
try:
    if sys.argv[1] == 'check':
        RET = check()
    elif sys.argv[1] == 'fix':
        RET = fix()
    elif sys.argv[1] == 'fixable':
        RET = fixable()
    else:
        print >>sys.stderr, "unsupported argument '%s'"%sys.argv[1]
        RET = RET_ERR
except:
    import traceback
    traceback.print_exc()
    sys.exit(RET_ERR)

sys.exit(RET)
