#!/opt/opensvc/bin/python
""" 
module use OSVC_COMP_USER_... vars
which define {'username':{'propname':'propval',... }, ...}

example: 
{"tibco":{"shell":"/bin/ksh","gecos":"agecos",},
 "tibco1":{"shell":"/bin/tcsh","gecos":"another gecos",},
}

supported dictionnary keys:
- uid
- gid
- gecos
- homedir
- shell
"""

import os
import sys
import json
import pwd
from subprocess import Popen, list2cmdline

RET_OK = 0
RET_ERR = 1
RET_NA = 2

RET = RET_ERR

PREFIX = 'OSVC_COMP_USER_'

pwt = {
    'shell': 'pw_shell',
    'homedir': 'pw_dir',
    'uid': 'pw_uid',
    'gid': 'pw_gid',
    'gecos': 'pw_gecos',
}

usermod_p = {
    'shell': '-s',
    'homedir': '-m -d',
    'uid': '-u',
    'gid': '-g',
    'gecos': '-c',
}

sysname, nodename, x, x, machine = os.uname()

if sysname not in ['SunOS', 'Linux']:
    print 'module not supported on', sysname
    sys.exit(RET_NA)

users = {}
for k in [ key for key in os.environ if key.startswith(PREFIX)]:
    try:
        users.update(json.loads(os.environ[k]))
    except ValueError:
        print 'user syntax error on var[', k, '] = ',os.environ[k]

if len(users) == 0:
    print "no applicable variable found in rulesets",PREFIX
    sys.exit(RET_NA)

def fixable():
    return RET_NA

def fix_item(user, item, target):
    cmd = ['usermod'] + usermod_p[item].split() + [str(target), user]
    print list2cmdline(cmd)
    p = Popen(cmd)
    out, err = p.communicate()
    r = p.returncode    
    if r == 0:
        return RET_OK
    else:
        return RET_ERR

def check_item(user, item, target, current, verbose=False):
    if target == current:
        if verbose:
            print 'OK: user:', user, item+':', current
        return RET_OK
    else:
        if verbose:
            print >>sys.stderr, 'user:', user, item+':', current, 'target:', target
        return RET_ERR 

def check_user(user, props):
    r = 0
    try:
        userinfo=pwd.getpwnam(user)
    except KeyError:
        if try_create_user(props):
            print >>sys.stderr, 'user', user, 'does not exist'
            return RET_ERR
        else:
            print 'user', user, 'does not exist and not enough info to create it'
            return RET_OK
    for prop in pwt:
        if prop in props:
            r |= check_item(user, prop, props[prop], getattr(userinfo, pwt[prop]), verbose=True)
    return r

def try_create_user(props):
    #
    # don't try to create user if passwd db is not 'files'
    # beware: 'files' db is the implicit default
    #
    if 'db' in props and props['db'] != 'files':
        return False
    if set(pwt.keys()) <= set(props.keys()):
        return True
    return False

def create_user(user, props):
    cmd = ['useradd']
    for item in pwt:
        prop = str(props[item])
        if len(prop) == 0:
            continue
        cmd = cmd + usermod_p[item].split() + [prop]
    cmd += [user]
    print list2cmdline(cmd)
    p = Popen(cmd)
    out, err = p.communicate()
    r = p.returncode    
    if r == 0:
        return RET_OK
    else:
        return RET_ERR

def fix_user(user, props):
    r = 0
    try:
        userinfo=pwd.getpwnam(user)
    except KeyError:
        if try_create_user(props):
            return create_user(user, props)
        else:
            print 'user', user, 'does not exist and not enough info to create it'
            return RET_OK
    for prop in pwt:
        if prop in props and \
           check_item(user, prop, props[prop], getattr(userinfo, pwt[prop])) != RET_OK:
            r |= fix_item(user, prop, props[prop])
    return r

def check():
    r = 0
    for user, props in users.items():
        r |= check_user(user, props)
    return r

def fix():
    r = 0
    for user, props in users.items():
        r |= fix_user(user, props)
    return r

#
# Main
#
if len(sys.argv) != 2:
    print >>sys.stderr, "need argument"
    sys.exit(RET_ERR)
try:
    if sys.argv[1] == 'check':
        RET = check()
    elif sys.argv[1] == 'fix':
        RET = fix()
    elif sys.argv[1] == 'fixable':
        RET = fixable()
    else:
        print >>sys.stderr, "unsupported argument '%s'"%sys.argv[1]
        RET = RET_ERR
except:
    import traceback
    traceback.print_exc()
    sys.exit(RET_ERR)
sys.exit(RET)
