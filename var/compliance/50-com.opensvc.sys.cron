#!/usr/bin/env python2.6

import os
import sys
import shutil
import glob
from subprocess import *

RET_OK = 0
RET_ERR = 1
RET_NA = 2

RET = 1
prefix = 'OSVC_COMP_CRON_ENTRY_'
ce = []

sysname, nodename, x, x, machine = os.uname()

class Unfixable(Exception):
     def __init__(self, s):
         self.s = s
     def __str__(self):
         return self.s

class ComplianceError(Exception):
     def __init__(self, s):
         self.s = s
     def __str__(self):
         return self.s

if sysname == 'SunOS' :
    crontab_locs = [
        '/var/spool/cron/crontabs'
    ]
else:
    crontab_locs = [
        '/etc/cron.d',
        '/var/spool/cron/crontabs',
        '/var/spool/cron',
        '/var/cron/tabs',
    ]

for k in os.environ:
    if k[:len(prefix)] == prefix:
        e = os.environ[k].split(':')
        if len(e) < 5:
            print >>sys.stderr, "malformed variable %s. format: action:user:sched:cmd:[file]"%k
            continue
        if e[0] not in ('add', 'del'):
            print >>sys.stderr, "unsupported action in variable %s. set 'add' or 'del'"%k
            continue
        if len(e[2].split()) != 5:
            print >>sys.stderr, "malformed schedule in variable %s"%k
            continue
        ce += [{
                'var': k,
                'action': e[0],
                'user': e[1],
                'sched': e[2],
                'cmd': e[3],
                'file': e[4],
               }]

if len(ce) == 0:
    print "no applicable variable found in rulesets"
    sys.exit(2)


def activate_cron(cron_file):
    """ Activate changes (actually only needed on HP-UX)
    """
    if '/var/spool/' in cron_file:
        print "tell crond about the change"
        cmd = ['crontab', cron_file]
        process = Popen(cmd, stdout=PIPE, stderr=PIPE, close_fds=True)
        buff = process.communicate()

def fixable_cron():
    r = RET_OK
    for e in ce:
        try:
            _fixable_cron(e)
        except ComplianceError, e:
            print >>sys.stderr, str(e)
            r = RET_ERR
        except Unfixable, e:
            print >>sys.stderr, str(e)
            return r
    return r

def fix_cron():
    r = RET_OK
    for e in ce:
        try:
            if e['action'] == 'add':
                _add_cron(e)
            elif e['action'] == 'del':
                _del_cron(e)
        except ComplianceError, e:
            print >>sys.stderr, str(e)
            r = RET_ERR
        except Unfixable, e:
            print >>sys.stderr, str(e)
            return r
    return r

def check_cron():
    r = RET_OK
    for e in ce:
        try:
            _check_cron(e)
        except ComplianceError, e:
            print >>sys.stderr, str(e)
            r = RET_ERR
        except Unfixable, e:
            print >>sys.stderr, str(e)
            return r
    return r

def get_cron_file(e):
    """ order of preference
    """
    cron_file = None
    for loc in crontab_locs:
        if not os.path.exists(loc):
            continue
        if loc == '/etc/cron.d':
             cron_file = os.path.join(loc, e['file'])
        else:
             cron_file = os.path.join(loc, e['user'])
        break
    return cron_file

def format_entry(cron_file, e):
    if 'cron.d' in cron_file:
        s = ' '.join([e['sched'], e['user'], e['cmd']])
    else:
        s = ' '.join([e['sched'], e['cmd']])
    return s

def _fixable_cron(e):
    cron_file = get_cron_file(e)

    if cron_file is None:
        raise Unfixable("no crontab usual location found (%s)"%str(crontab_locs))

def _check_cron(e):
    cron_file = get_cron_file(e)

    if cron_file is None:
        raise Unfixable("no crontab usual location found (%s)"%str(crontab_locs))

    s = format_entry(cron_file, e)

    if not os.path.exists(cron_file):
        raise ComplianceError("cron entry not found '%s' in '%s'"%(s, cron_file))

    with open(cron_file, 'r') as f:
        new = f.readlines()
        found = False
        for line in new:
            if s == line[:-1]:
                 found = True
                 break
        if not found and e['action'] == 'add':
            raise ComplianceError("wanted cron entry not found: '%s' in '%s'"%(s, cron_file))
        if found and e['action'] == 'del':
            raise ComplianceError("unwanted cron entry found: '%s' in '%s'"%(s, cron_file))

def _del_cron(e):
    cron_file = get_cron_file(e)

    if cron_file is None:
        raise Unfixable("no crontab usual location found (%s)"%str(crontab_locs))

    s = format_entry(cron_file, e)

    if not os.path.exists(cron_file):
        return

    new = []
    with open(cron_file, 'r') as f:
        lines = f.readlines()
        for line in lines:
            if s == line[:-1]:
                print "delete entry '%s' from '%s'"%(s, cron_file)
                continue
            new.append(line)

    if len(new) == 0:
        print 'deleted last entry of %s. delete file too.'%cron_file
        os.unlink(cron_file)
    else:
        with open(cron_file, 'w') as f:
            f.write(''.join(new))
        activate_cron(cron_file)

def _add_cron(e):
    cron_file = get_cron_file(e)

    if cron_file is None:
        raise Unfixable("no crontab usual location found (%s)"%str(crontab_locs))

    s = format_entry(cron_file, e)

    new = False
    if os.path.exists(cron_file):
        with open(cron_file, 'r') as f:
            new = f.readlines()
            found = False
            for line in new:
                if s == line[:-1]:
                    found = True
                    break
            if not found:
                new.append(s+'\n')
    else:
        new = [s+'\n']

    if not new:
        raise ComplianceError("problem preparing the new crontab '%s'"%cron_file)
 
    print "add entry '%s' to '%s'"%(s, cron_file)
    with open(cron_file, 'w') as f:
        f.write(''.join(new))
    activate_cron(cron_file)

#
# Main
#
if len(sys.argv) != 2:
    print >>sys.stderr, "need argument"
    sys.exit(1)

if sys.argv[1] == 'check':
    sys.exit(check_cron())
elif sys.argv[1] == 'fix':
    sys.exit(fix_cron())
elif sys.argv[1] == 'fixable':
    sys.exit(fixable_cron())
else:
    print >>sys.stderr, "unsupported argument '%s'"%sys.argv[1]
    sys.exit(RET_ERR)
