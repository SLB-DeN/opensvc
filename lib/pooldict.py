import sys
from rcGlobalEnv import rcEnv
from keywords import KeywordStore

# deprecated => supported
DEPRECATED_KEYWORDS = {
}

# supported => deprecated
REVERSE_DEPRECATED_KEYWORDS = {
}

DEPRECATED_SECTIONS = {
}

BASE_SECTIONS = [
]

KEYWORDS = [
    {
        "section": "DEFAULT",
        "keyword": "id",
        "inheritance": "head",
        "default_text": "<random uuid>",
        "text": "A RFC 4122 random uuid generated by the agent. To use as reference in resources definitions instead of the service name, so the service can be renamed without affecting the resources."
    },
    {
        "section": "DEFAULT",
        "keyword": "disable",
        "inheritance": "leaf",
        "generic": True,
        "at": True,
        "candidates": (True, False),
        "default": False,
        "convert": "boolean",
        "text": "A disabled resource will be ignored on service startup and shutdown. Its status is always reported ``n/a``.\n\nSet in DEFAULT, the whole service is disabled. A disabled service does not honor start and stop actions. These actions immediately return success.\n\n:cmd:`sudo svcmgr -s <svcname> disable` only sets :kw:`DEFAULT.disable`. As resources disabled state is not changed, :cmd:`sudo svcmgr -s <svcname> enable` does not enable disabled resources."
    },
    {
        "section": "DEFAULT",
        "keyword": "env",
        "inheritance": "head",
        "default_text": "<same as node env>",
        "candidates": rcEnv.allowed_svc_envs,
        "text": "A non-PRD service can not be brought up on a PRD node, but a PRD service can be startup on a non-PRD node (in a DRP situation). The default value is the node env."
    },
    {
        "section": "DEFAULT",
        "keyword": "lock_timeout",
        "default": 60,
        "convert": "duration",
        "text": "A duration expression, like '1m30s'. The maximum wait time for the action lock acquire. The svcmgr --waitlock option overrides this parameter."
    },
    {
        "section": "DEFAULT",
        "keyword": "kind",
        "inheritance": "head",
        "at": True,
        "default": "pool",
        "candidates": ("pool"),
        "text": "Defines the kind of service.",
    },
    {
        "section": "DEFAULT",
        "keyword": "nodes",
        "inheritance": "head",
        "at": True,
        "convert": "nodes_selector",
        "default": rcEnv.nodename,
        "default_text": "<hostname of the current node>",
        "text": "A node selector expression specifying the list of cluster nodes hosting service instances."
    },
    {
        "section": "DEFAULT",
        "keyword": "drpnodes",
        "inheritance": "head",
        "at": True,
        "convert": "list_lower",
        "default": [],
        "default_text": "",
        "text": "Alternate backup nodes, where the service could be activated in a DRP situation if the 'drpnode' is not available. These nodes are also data synchronization targets for 'sync' resources.",
        "example": "node1 node2"
    },
    {
        "section": "pool",
        "keyword": "type",
        "default": "directory",
        "candidates": ["directory", "loop", "vg", "zpool", "freenas", "share", "symmetrix", "shm", "virtual"],
        "text": "The pool type."
    },
    {
        "section": "pool",
        "keyword": "mnt_opt",
        "at": True,
        "text": "The mount options of the fs created over the pool devices."
    },
    {
        "section": "pool",
        "rtype": ["freenas", "symmetrix"],
        "keyword": "array",
        "at": True,
        "required": True,
        "text": "The name of the array, as known to the auth.conf."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "srp",
        "required": True,
        "text": "The name of the array resource pool to allocate volumes from."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "slo",
        "default": None,
        "text": "The name of the Service Level Agreement of the selected Storage Group."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "srdf",
        "default": False,
        "text": "Use SRDF replication."
    },
    {
        "section": "pool",
        "rtype": "symmetrix",
        "keyword": "rdfg",
        "default": None,
        "text": "Replication Group to use for SRDF."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "diskgroup",
        "required": True,
        "text": "The name of the array disk group to allocate volumes from."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "insecure_tpc",
        "default": False,
        "text": "Allow initiators to xcopy without authenticating to foreign targets."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "compression",
        "default": "inherit",
        "candidates": ["inherit", "none", "lz4", "gzip-1", "gzip-2", "gzip-3", "gzip-4", "gzip-5", "gzip-6", "gzip-7", "gzip-8", "gzip-9", "zle", "lzjb"],
        "text": "Compression level.",
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "sparse",
        "default": False,
        "text": "Create zvol in sparse mode."
    },
    {
        "section": "pool",
        "rtype": "freenas",
        "keyword": "blocksize",
        "default": 512,
        "convert": "size",
        "text": "Allow initiators to xcopy without authenticating to foreign targets."
    },
    {
        "section": "pool",
        "rtype": "vg",
        "keyword": "name",
        "required": True,
        "text": "The name of the volume group to allocate the pool logical volumes into."
    },
    {
        "section": "pool",
        "rtype": "zpool",
        "keyword": "name",
        "required": True,
        "text": "The name of the zpool to allocate the pool datasets into."
    },
    {
        "section": "pool",
        "keyword": "path",
        "rtype": ["directory", "share"],
        "default": "{var}/pool/directory",
        "text": "The path to create the pool loop files in."
    },
    {
        "section": "pool",
        "keyword": "template",
        "rtype": ["virtual"],
        "text": "The service path (<namespace>/<svcname>) of a volume service to use as a template for new volumes.",
    },
    {
        "section": "pool",
        "keyword": "volume_env",
        "rtype": ["virtual"],
        "convert": "list",
        "example": "container#1.name:container_name env.foo:foo",
        "text": "The list of the volume consumer service config keywords which values are mapped as env keys in the allocated volume service.",
    },
    {
        "section": "pool",
        "keyword": "capabilities",
        "rtype": ["virtual"],
        "convert": "list",
        "default": ["roo", "rwo", "rox", "rwx"],
        "text": "The capabilities exposed by the virtual pool.",
    },
    {
        "section": "pool",
        "keyword": "path",
        "rtype": "loop",
        "default": "{var}/pool/loop",
        "text": "The path to create the pool loop files in."
    },
    {
        "section": "pool",
        "keyword": "fs_type",
        "default": "xfs",
        "text": "The filesystem to format the pool devices with."
    },
    {
        "section": "pool",
        "keyword": "mkfs_opt",
        "default": [],
        "convert": "shlex",
        "example": "-O largefile",
        "text": "The mkfs command options to use to format the pool devices."
    },
    {
        "section": "pool",
        "keyword": "mkblk_opt",
        "default": [],
        "convert": "shlex",
        "text": "The zvol, lv, and other block device creation command options to use to prepare the pool devices."
    },
]

KEYS = KeywordStore(
    keywords=KEYWORDS,
    deprecated_keywords=DEPRECATED_KEYWORDS,
    deprecated_sections=DEPRECATED_SECTIONS,
    template_prefix="template.pool.",
    base_sections=BASE_SECTIONS,
    has_default_section=False,
 )

if __name__ == "__main__":
    if len(sys.argv) == 2:
        fmt = sys.argv[1]
    else:
        fmt = "text"

    KEYS.write_templates(fmt=fmt)

